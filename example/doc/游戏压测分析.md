## 前言

游戏行业的开源氛围并不浓,大部分项目都是自己造各种轮子.我在前些年无知无畏还敢把自己的一点心得拿出来分享,后面学的越多发现自己缺的越多,反而不敢写东西出来误人子弟了,最近优化了项目的压测工具,现在斗胆从这个压测模块入手,基于这个压测工具项目分享一些自己对游戏开发的理解和经验.

[GameRobot](https://github.com/Rookiexu/GameRobot)

## 为什么要做这个项目

版号时代以来大部分项目到不了上线,好不容易上线的项目还有很多出现炸服之类的运营事故,炸服原因千千万万,如果能做好压测其实是可以避免其中一大部分的  
在我参与的上线项目中有自己开发的压测工具,它模拟成千上万的玩家,每个玩家分功能模块通过预置的消息顺序,向游戏服务器发送一应一答的测试消息,我们通过监控响应吞吐量,服务器gc,系统资源消耗来评判压测情况.
类似的方案应该也有很多项目在使用,它本身可以满足大部分的游戏需求,但是在我的使用中还是发现了一些痛点.

首先是玩家行为模拟并不仿真,在一些强状态的模块测试会很复杂或者很不拟真,比如玩家的战斗模块测试,玩家会一边移动一边使用技能,道具等等,很难通过指定消息顺序就完成整个战斗功能的模拟和测试

其次是测试偏重整体吞吐量而忽略了响应耗时甚至慢响应这些重要的体验参数,很多时候服务器对自己的卡顿感知并不强,比如出现GC或者IO线程bug,只靠服务器运行日志无法发现任何异常,所以响应耗时这个参数也非常重要.

基于对这些问题的思考,我另外写了GameRobot这个压测工具,用自己的代码做了解答,接下来我也详细的谈谈我对游戏压测这个事情的理解.

## 游戏压测和web压测区别

**一应一答,顺序关系清晰**

基于http请求的web响应,操作天生是一应一答的,从我自己的体验来看web的操作前后关系大多比游戏更加明确,比如一个im系统的发消息,撤回消息和接收消息:

1. 接收消息最为独立,它和发消息,撤回消息互不影响
2. 对同一条消息而言,发消息则必然先于撤回消息

所以聊天的测试顺序就很明确,先发后撤,接收随意.其实大部分游戏模块也是类似的,比如好友,社团,这类游戏功能本身就是简化的web系统,对于这类的功能就完全可以直接使用一应一答的测试逻辑.

**无序但是有前后影响**

游戏一个麻烦的点在于,它大部分时候都有一堆状态需要维持,这导致很多无序但是前后影响很大的情况出现,比如战斗模块,玩家移动,释放技能,使用道具补血补蓝.

1. 对某些攻击,玩家需要移动躲避
2. 使用技能要判断血蓝状态,距离远近

战斗中所有事件的请求顺序前后影响又随意穿插,如果还是使用一问一答,要么接受现实配置几个简单的请求,要么为了模拟的真实,配置一个包含几十上百次请求的消息执行顺序出来,

为了解决这个问题GameRobot引入了基于决策树/行为树的游戏AI,通过配置的参数,自决策玩家在一个模块中需要发送的请求,解决在复杂状态下的玩家模拟

* 行为树的AI我曾经写了另外一个项目可以作为参考,GameRobot的AI模块其实也是复刻的这个项目 ---项目连接--- ,

## 压测业务分析

### 游戏到各个功能

分析完压测消息的响应模型,再从整个游戏到各个功能模块分析一下压测,游戏中有很多功能模块,比如登录,道具,抽卡,英雄养成,战斗,好友等等,细分的话他们在测试时也有区分

1. 登录模块是整个游戏功能的前置模块,不完成登录,无法进入后续游戏功能
2. 英雄养成需要获得某些英雄,才能对这些英雄的养成进行测试,有一定的先后顺序需求
3. 抽卡,好友等功能其实是毫无关联的,模块之前没有顺序执行的需求

从以上三个角度分析下来,功能模块大致可以分为三个类型:前置模块,顺序模块,无序模块

其中前置模块作为等个测试的基石,所有测试都要先执行前置模块,同时前置模块只需要执行一次
顺序模块,无序模块则通过对顺序的配置,实现各个模块的排序

### 功能到各个消息

分析完游戏到功能,在分析一下功能到各个消息有怎样的区分

对一个模块来说,同样可能存在前置消息,假设我们不通过英雄功能获得英雄,而是通过gm指令在测试英雄养成时获得对应英雄,那么获得指定英雄的gm指令就是整个英雄模块的前置消息
同样一个模块的消息也可以有先后顺序,比如好友推荐和好友添加,也有完全无所谓先后的消息,比如装备强化,英雄升级等等,除此之外,在gameRobot中还有特别添加的ai消息,即整个模块,不存在先后,通过ai配置决定消息的发送顺序


## 压测到底测什么

---当我们说压测的时候,我们到底是要得到什么
分析了那么多压测的业务,最后分析一下在我的理解中到底需要从压测过程中监测些什么,获得些什么.

### 服务器角度

从服务器的角度来说,压测是主要是测试吞吐量,并发用户数,以及cpu,内存,io,磁盘等等资源利用率,特定语言服务器如java的话还需要考虑gc情况

### 客户端角度

说完服务器再说说客户端,客户端压测主要是测试消息响应速度

前面有提到过,很多时候游戏服务器对自己的停顿感知并不强,如果出现了gc,或者io线程的bug,很难从服务器日志发现异常,我在很早之前的项目就遇到过一个写在io线程中的隐秘bug
代码在登录时尝试获取玩家ip的地址名getAddressName(),看起来只是一个普通的get属性方法,但实际上会访问DNS,这个耗时非常不稳定,有时几ms,有时几秒,如果同时登录且耗时长的玩家一多,整个io线程上的玩家都会受影响,最后因为心跳长时间无响应,线程上的客户端都主动断开连接,由于只是部分玩家离线,在日志中看起来只是普通的玩家离线,bug非常隐秘
最后的解决也是通过创建一个特殊的客户端,长时间监测服务器连接和响应耗时,最后定位了问题所在.所以响应速度应当是一个重要的监测参数.

### 如何采集

GameRobot中基于发布订阅的模式,在执行过程中抛出各种事件,记录线程订阅相关事件通过一个个时间窗口来采集,实现了在线人数,吞吐量,99%响应,平均响应,慢消息详情等等的统计,如果二次开发也可以自定义订阅者去实现各种信息统计


## 最后

这篇文章是我对游戏压测的分析,以及gameRobot的设计由来,也包含了一些我对游戏开发的理解和踩过的坑,希望我的分享可以帮到需要的人,也欢迎对这个项目提交star和issue,如果后面有时间我再对GameRobot的代码实现做些说明.